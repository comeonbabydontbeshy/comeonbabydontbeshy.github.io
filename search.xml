<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++四种强制类型转换</title>
      <link href="/2021/11/08/c-si-chong-qiang-zhi-lei-xing-zhuan-huan/"/>
      <url>/2021/11/08/c-si-chong-qiang-zhi-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>有时我们希望显式地将对象转换为另外一种类型。例如，如果想在下面的代码中执行浮点数除法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">double</span> slope = i/j;<br></code></pre></td></tr></tbody></table></figure><p>就要使用某种方法将<code>i/j</code>的结果显示地转换为double。这种方法称作强制类型转换。</p><h3 id="C风格的强制类型转换"><a href="#C风格的强制类型转换" class="headerlink" title="C风格的强制类型转换"></a>C风格的强制类型转换</h3><p>C风格地进行强制类型转换包含两种形式:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">type(expr);<br>(type)type;<br></code></pre></td></tr></tbody></table></figure><p>C风格的强制类型转换从表现形式上来说不那么清楚明了，一旦出现问题，追踪起来比较困难。</p><h3 id="C-风格的强制类型转换"><a href="#C-风格的强制类型转换" class="headerlink" title="C++风格的强制类型转换"></a>C++风格的强制类型转换</h3><p>C++风格的强制类型转换具有如下形式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cast-name&lt;type&gt;(expression);<br></code></pre></td></tr></tbody></table></figure><p><code>cast-name</code>可以是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><p><code>static_cast</code>会在编译期间对类型转换做安全检查，防止不必要的错误。几个主要的用法如下：</p><ol><li><p>基础类型间的转换，如<code>int</code>转为<code>char</code>,float转为double。因为<code>static_cast</code>明确告诉编译器是在知情情况下发生的类型转换，所以对可能的精度损失不会告警。把精度大的值转换为精度小的值，<code>static_cast</code>会做截断处理。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> n1 = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-keyword">int32_t</span> n2 = n1;                                   <span class="hljs-comment">//  warning: conversion from 'int64_t' {aka 'long long int'} to 'int32_t' {aka 'int'} may change value</span><br><span class="hljs-keyword">int32_t</span> n3 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;(n1);             <span class="hljs-comment">//  no warning</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>把任意类型转换为void类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> num=<span class="hljs-number">64</span>;<br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>&gt;(num);<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>void*</code>指针和目标类型指针的相互转换</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> strArr[<span class="hljs-number">11</span>] = <span class="hljs-string">"helloworld"</span>;<br><span class="hljs-keyword">void</span> *pVoid = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(strArr);<br><span class="hljs-keyword">char</span>* ptrStr=<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pVoid);<br></code></pre></td></tr></tbody></table></figure></li><li><p>用于基类和子类间的转换，但没有运行时类型检查保证转换安全，其中，子类转基类是安全的，但是父类转子类是不安全的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {</span>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B {};<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B* pb, D* pd)</span> </span>{<br>  D* pd2 = <span class="hljs-keyword">static_cast</span>&lt;D*&gt;(pb);   <span class="hljs-comment">// Not safe, D can have fields</span><br>                                   <span class="hljs-comment">// and methods that are not in B.</span><br><br>  B* pb2 = <span class="hljs-keyword">static_cast</span>&lt;B*&gt;(pd);   <span class="hljs-comment">// Safe conversion, D always</span><br>                                   <span class="hljs-comment">// contains all of B.</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>static_cast</code>不能进行无关类型（如非父类和子类）指针之间的转换</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> n1 = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-comment">// error: invalid static_cast from type 'int64_t*' {aka 'long long int*'} to type 'char*'</span><br><span class="hljs-keyword">char</span>* ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(&amp;n1); <br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast转换符是用来移除变量的const或volatile限定符。对于const变量，我们无法直接改变它的值，这个时候<code>const_cast</code>可以派上用场</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAddr</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span>* ptr)</span></span><br><span class="hljs-function"></span>{<br>    std::cout&lt;&lt;std::hex&lt;&lt;ptr&lt;&lt;std::oct&lt;&lt;std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span>* ptrNum=&amp;num;<br>    <span class="hljs-comment">//printAddr(ptrNum);     invalid conversion from 'const int32_t*' {aka 'const int*'} to 'int32_t*'</span><br>    <span class="hljs-built_in">printAddr</span>(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int32_t</span>*&gt;(ptrNum));<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p><code>reinterpret</code>字面意识是重新解释，<code>reinterpret_cast</code>可以理解为重新解释数值，它可以实现</p><ol><li><p>任意类型指针转换为其他无关类型的指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span></span><br><span class="hljs-class">{</span><br>    <span class="hljs-keyword">int32_t</span> num;<br>    <span class="hljs-keyword">char</span> ch;<br>};<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Data data{<span class="hljs-number">0x12345678</span>,<span class="hljs-string">'A'</span>};<br>    <span class="hljs-keyword">int32_t</span>* ptr=<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int32_t</span>*&gt;(&amp;data);<br>    std::cout&lt;&lt;std::hex&lt;&lt;*ptr&lt;&lt;std::endl;   <span class="hljs-comment">//  0x12345678</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>整形转换为任意类型指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">uint64_t</span> addr = <span class="hljs-number">0x12345678FFFFFFFF</span>;<br><span class="hljs-keyword">char</span>* ptr=<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(addr);<br>std::cout&lt;&lt;std::hex&lt;&lt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)&lt;&lt;std::endl;    <span class="hljs-comment">// 0x12345678FFFFFFFF</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>任意类型指针转换为足够大的整形</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> ch = <span class="hljs-string">'A'</span>;<br><span class="hljs-comment">//uint32_t lAddr=reinterpret_cast&lt;uint32_t&gt;(&amp;ch);   error: cast from 'char*' to 'uint32_t' {aka 'unsigned int'} loses precision</span><br><span class="hljs-keyword">uint64_t</span> lAddr = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(&amp;ch);<br>std::cout &lt;&lt; std::hex &lt;&lt; <span class="hljs-string">"lAddr : "</span> &lt;&lt; lAddr &lt;&lt; <span class="hljs-string">" , ch addr : "</span> &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(&amp;ch) &lt;&lt; std::endl;<br><span class="hljs-comment">// llNum : 0x65fe17 , ch addr : 0x65fe17</span><br></code></pre></td></tr></tbody></table></figure></li></ol><p><code>reinterpret_cast</code>不考虑转换数值类型之间是否是相关的，所以存在相当大的不安全性,如下例子整形指针转换为函数指针最终导致崩溃</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*pFunc)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">100</span>;<br>    pFunc pf=<span class="hljs-keyword">reinterpret_cast</span>&lt;pFunc&gt;(&amp;num);<br>    <span class="hljs-built_in">pf</span>(<span class="hljs-number">3</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><p><code>dynamic_cast</code>用于将基类的指针或引用安全地转换成派生类的指针或引用(基类至少要包含一个虚函数)，该转换特别适用于我们想使用基类对象的指针或引用执行某个派生类操作且该操作不是虚函数的情况。如果<code>dynamic_cast</code>转换失败了，如果转换目标是指针类型则返回空指针，如果是引用类型则会抛出一个<code>bad_alloc</code>异常</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CAnimal</span></span><br><span class="hljs-class">{</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        <br>    }<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CAnimal</span>()<br>    {<br><br>    }<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDog</span>:</span><span class="hljs-keyword">public</span> CAnimal<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        std::cout&lt;&lt;<span class="hljs-string">"bark"</span>&lt;&lt;std::endl;<br>    }<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CDog</span>()<br>    {<br>        <br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    CAnimal* animal=<span class="hljs-keyword">new</span> CDog;<br>    CDog* dog=<span class="hljs-keyword">dynamic_cast</span>&lt;CDog*&gt;(animal);<br>    <span class="hljs-keyword">if</span> (dog)<br>    {<br>        dog-&gt;<span class="hljs-built_in">bark</span>();<br>    }<br>    <span class="hljs-keyword">delete</span> animal;<br>}<br></code></pre></td></tr></tbody></table></figure><p>PS:通过运行时类型识别(<code>run-time type identification,RTTI</code>)，程序能够通过基类的指针或引用来检索其所指对象的实际类型。 <code>dynamic_cast</code>是<code>C++</code>中<code>RTTI</code>的一种实现，另一个是<code>typdid</code>。对于带虚函数的类，在运行时执行<code>RTTI</code>操作符，返回动态类型信息；对于其他类型，在编译时执行<code>RTTI</code>，返回静态类型信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>C++</code>支持4种强制类型转换：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code></li><li><code>static_cast</code>会在编译期间对类型转换做安全检查，多用于基础类型的转换，是工作中常用的一种显示转换</li><li><code>dynamic_cast</code>提供了<code>RTTI</code>的功能，支持将带虚函数的基类指针或引用安全地转换为派生类的指针或引用</li><li><code>const_cast</code>用于移除变量的const或volatile限定符</li><li><code>reinterpret_cast</code>支持任意指针类型间的相互转换，功能强大但也比较危险，使用时要谨慎</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[^1]https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2012/5f6c9f8h(v=vs.110)<br>[^2]https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1?topic=operators-cast-expressions<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觉得不错的书单</title>
      <link href="/2021/11/07/shu-dan/"/>
      <url>/2021/11/07/shu-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><ol><li>C程序设计语言</li><li>C和指针</li><li>C陷阱与缺陷</li><li>C专家编程</li></ol><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><ol><li>C++ primer</li><li>C++标准库</li><li>深度探索 C++ 对象模型</li><li>Effective C++</li><li>Effective Modern C++</li></ol><h3 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix\Linux"></a>Unix\Linux</h3><ol><li>UNIX编程艺术</li><li>UNIX环境高级编程</li><li>UNIX 网络编程卷 1：套接字 API</li><li>UNIX 网络编程卷 2：进程间通信</li><li>深入理解linux内核</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>深入理解计算机系统</li><li>操作系统–精髓与设计原理</li><li>程序员的自我修养：链接、装载与库</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol><li>Head First设计模式</li><li>设计模式: 可复用面向对象软件的基础</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>算法导论</li><li>编程珠玑</li><li>数据结构与算法分析：C语言描述</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>测试驱动开发</li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li>Docker从入门到实践</li><li>Docker容器与容器云</li></ol>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
