<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>auto类型推导</title>
    <link href="/2021/11/13/auto-lei-xing-tui-dao/"/>
    <url>/2021/11/13/auto-lei-xing-tui-dao/</url>
    
    <content type="html"><![CDATA[<h3 id="auto的作用"><a href="#auto的作用" class="headerlink" title="auto的作用"></a><code>auto</code>的作用</h3><p><code>auto</code>是我在编码中经常使用到的<code>C++11</code>新特性之一，主要用于变量的自动类型推导，如<code>auto num=3</code>，则推导出<code>num</code>的类型为<code>int32_t</code></p><h3 id="auto的优势"><a href="#auto的优势" class="headerlink" title="auto的优势"></a><code>auto</code>的优势</h3><p>相较于原始的显式类型去声明变量类型，<code>auto</code>的优势有以下几点：</p><ol><li><p><code>auto</code>变量一定要被初始化，可以避免变量忘记初始化</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto i;                 //   error: declaration of 'auto i' has no initializer</span><br>auot i=<span class="hljs-number">1</span>;                  <span class="hljs-comment">//   ok</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>可简化变量/对象的声明</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int32_t</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-keyword">auto</span> iter=vec.<span class="hljs-built_in">begin</span>();     <span class="hljs-comment">//   auto自动推导为std::vector&lt;int32_t&gt;::iterator</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>在某些场合无法判断出类型时，可用auto自动推导（如<code>lambda</code>表达式）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func = [](<span class="hljs-keyword">int32_t</span> a, <span class="hljs-keyword">int32_t</span> b)<br>    {<br>        <span class="hljs-keyword">return</span> a + b;<br>    }<br></code></pre></td></tr></tbody></table></figure></li><li><p>可自适应类型，避免类型转换出现可能的类型错误</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">getFileSize</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&amp; filePath)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">std::fstream <span class="hljs-title">fs</span><span class="hljs-params">(filePath,std::ios::in|std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-built_in">is_open</span>())<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    fs.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>,std::ios::end);<br>    <span class="hljs-keyword">int64_t</span> len=fs.<span class="hljs-built_in">tellg</span>();<br>    fs.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> len;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// int32_t len=getFileSize("./main.exe");            //  可能发生整形溢出</span><br>    <span class="hljs-keyword">auto</span> len=<span class="hljs-built_in">getFileSize</span>(<span class="hljs-string">"./main.exe"</span>);                  <span class="hljs-comment">//  自动推导为int64_t类型</span><br>}<br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="auto类型推断"><a href="#auto类型推断" class="headerlink" title="auto类型推断"></a><code>auto</code>类型推断</h3><p><code>auto</code>类型推断的逻辑和模板类型推断是一致的，所以我们可以先了解下模板类型推断规则，然后再去推广到<code>auto</code>类型推断</p><p>模板类型推断，我们可以以一段伪代码为例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>;<br><br><span class="hljs-comment">// 模板函数调用</span><br><span class="hljs-built_in">f</span>(expr);<br></code></pre></td></tr></tbody></table></figure><p>在编译过程中编译器会使用<code>expr</code>推断两种类型：一个T的类型，一个是<code>ParamType</code>。而这两种类型往往是不一样的，因为<code>ParamType</code>通常会包含修饰符，比如<code>const</code>或者引用,所以这里模板函数推断过程可以分为以下几种情况</p><ul><li><p><code>ParamType</code>是指针或普通引用类型,模板函数如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>推导的过程如下</p><ol><li><p>若<code>expr</code>具有引用类型，先将引用部分忽略</p></li><li><p>对<code>expr</code>的类型和<code>ParamType</code>的类型进行匹配，来决定<code>T</code>的类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int32_t</span> x=<span class="hljs-number">27</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> cx=x;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span>&amp; rx=x;<br><span class="hljs-built_in">f</span>(x);    <span class="hljs-comment">//   void f&lt;int32_t&gt;(int32_t &amp;param),T的类型为int32_t,param的类型为int32_t&amp;                 </span><br><span class="hljs-built_in">f</span>(cx);   <span class="hljs-comment">//   void f&lt;const int32_t&gt;(const int32_t &amp;param),T的类型为const int32_t,param的类型为const int32_t&amp;</span><br><span class="hljs-built_in">f</span>(rx);   <span class="hljs-comment">//   void f&lt;const int32_t&gt;(const int32_t &amp;param),T的类型为const int32_t,param的类型为const int32_t&amp;</span><br></code></pre></td></tr></tbody></table></figure></li></ol></li><li><p><code>ParamType</code>是一个万能引用(<code>Universal Reference</code>),模板函数如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp;&amp; param)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>推导的过程如下</p><ol><li><p>如果<code>expr</code>是个左值，<code>T</code>和<code>ParamType</code>都会被推导为左值引用。首先，这是模板类型推断中唯一将T推断为引用的情况；其次，虽然<code>ParamType</code>的声明使用右值引用语法，但它最终却被推断成左值引用。</p></li><li><p>如果<code>expr</code>是个右值，参考<code>ParamType</code>是指针或者普通引用类型情况，先将引用部分忽略，然后<code>expr</code>和<code>ParamTyoe</code>的类型进行匹配，来决定<code>T</code>的类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int32_t</span> x=<span class="hljs-number">27</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> cx=x;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span>&amp; rx=x;<br><span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">//   void f&lt;int32_t &amp;&gt;(int32_t &amp;param),T的类型为int32_t&amp;,param的类型为int32_t&amp;       </span><br><span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">//   void f&lt;const int32_t &amp;&gt;(const int32_t &amp;param),T的类型为const int32_t&amp;,param的类型为const int32_t&amp;   </span><br><span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">//   void f&lt;const int32_t &amp;&gt;(const int32_t &amp;param),T的类型为const int32_t&amp;,param的类型为const int32_t&amp; </span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>);  <span class="hljs-comment">//   void f&lt;int&gt;(int &amp;&amp;param),T的类型为int32_t,param的类型为int32_t&amp;&amp;</span><br></code></pre></td></tr></tbody></table></figure></li></ol></li><li><p><code>ParamType</code>既不是指针也不是引用。这种情况也就是所谓的按值传递,模板函数如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>无论传入的是什么<code>expr</code>,<code>param</code>也只是一份副本。推导的过程如下：</p><ol><li><p>若<code>expr</code>具有引用类型，则忽略其引用部分</p></li><li><p>若<code>expr</code>携带<code>const</code>限定符，也忽略它</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int32_t</span> x=<span class="hljs-number">27</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> cx=x;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span>&amp; rx=x;<br><span class="hljs-built_in">f</span>(x);   <span class="hljs-comment">//  void f&lt;int32_t&gt;(int32_t param),T的类型为int32_t,param的类型为int32_t      </span><br><span class="hljs-built_in">f</span>(cx);  <span class="hljs-comment">//  void f&lt;int32_t&gt;(int32_t param),T的类型为int32_t,param的类型为int32_t</span><br><span class="hljs-built_in">f</span>(rx);  <span class="hljs-comment">//  void f&lt;int32_t&gt;(int32_t param),T的类型为int32_t,param的类型为int32_t</span><br><span class="hljs-built_in">f</span>(<span class="hljs-number">27</span>);  <span class="hljs-comment">//  void f&lt;int32_t&gt;(int32_t param),T的类型为int32_t,param的类型为int32_t</span><br></code></pre></td></tr></tbody></table></figure></li></ol></li><li><p>数组参数属于模板类型推断的一种特殊情况</p><ol><li><p>按值传递时由于数组退化为指针的规则，数组参数会被当做指针参数来处理，所以数组会被推断为一个指针类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span><br><span class="hljs-function"></span>{<br><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> szName[]=<span class="hljs-string">"Mark Lin"</span>;       <span class="hljs-comment">// szName的类型为const char szName[9]</span><br>    <span class="hljs-built_in">f</span>(szName);   <span class="hljs-comment">//  void f&lt;const char *&gt;(const char *param),T的类型为const char*,param的类型为const char*</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>ParamType</code>是指针或普通引用类型，<code>T</code>的类型会被推导为数组类型，<code>ParamType</code>则为数组引用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T&amp; param)</span></span><br><span class="hljs-function"></span>{<br><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> szName[]=<span class="hljs-string">"Mark Lin"</span>;     <span class="hljs-comment">//   szName的类型为const char szName[9]</span><br>    <span class="hljs-built_in">f</span>(szName);  <span class="hljs-comment">//  void f&lt;const char [9]&gt;(const char (&amp;param)[9]),T的类型为const char[9],param的类型为const char (&amp;)[9])</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>使用这种声明有一个妙用。我们可以创建一个模板来推断出数组中包含的元素数量：</p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">template&lt;typename <span class="hljs-built_in">T</span>, s<span class="hljs-symbol">td:</span><span class="hljs-symbol">:si</span>ze_t <span class="hljs-built_in">N</span>&gt; <br>constexpr s<span class="hljs-symbol">td:</span><span class="hljs-symbol">:si</span>ze_t arraySize(<span class="hljs-built_in">T</span> (&amp;)[<span class="hljs-built_in">N</span>]) noexcept <br>{ <br>    return <span class="hljs-built_in">N</span>; <br>} <br></code></pre></td></tr></tbody></table></figure></li></ol></li></ul><p><code>auto</code>的类型推断机制是和模板类型推断是一致的，<strong>auto关键字扮演的是模板类型推断中T的角色</strong>,而类型说明符扮演的是<code>ParamType</code>的角色</p><ul><li><p><code>auto</code>修饰为指针或普通引用类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类比如下模板函数</span><br><span class="hljs-comment">//template&lt;typename T&gt;</span><br><span class="hljs-comment">//void f(T&amp; param)</span><br><br> <span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">27</span>;<br> <span class="hljs-keyword">auto</span>&amp; x=num;   <span class="hljs-comment">// auto被推断为int32_t,x的类型为int32_t&amp;</span><br> <span class="hljs-keyword">auto</span>&amp; lx=x;    <span class="hljs-comment">// auto被推断为int32_t,lx的类型为int32_t&amp;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>auto</code>修饰是一个万能引用(<code>Universal Reference</code>)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类比如下模板函数</span><br><span class="hljs-comment">//template&lt;typename T&gt;</span><br><span class="hljs-comment">//void f(T&amp;&amp; param)</span><br><br><span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">27</span>;<br><span class="hljs-keyword">auto</span>&amp;&amp; x=num;   <span class="hljs-comment">// auto被推断为int32_t&amp;,rx的类型为int32_t&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; lx=x;    <span class="hljs-comment">// auto被推断为int32_t&amp;,rx的类型为int32_t&amp;</span><br><span class="hljs-keyword">auto</span>&amp;&amp; rx=<span class="hljs-number">27</span>;   <span class="hljs-comment">// auto被推断为int32_t,rx的类型为int32_t&amp;&amp;</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>ParamType</code>既不是指针也不是引用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类比如下模板函数</span><br><span class="hljs-comment">//template&lt;typename T&gt;</span><br><span class="hljs-comment">//void f(T param)</span><br><br><span class="hljs-keyword">auto</span> x = <span class="hljs-number">27</span>;   <span class="hljs-comment">// auto被推断为int32_t,x的类型为int32_t</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cx = x;  <span class="hljs-comment">// auto被推断为int32_t,cx的类型为const int32_t</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>数组参数和函数指针的情况</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> name[] =  <span class="hljs-string">"R. N. Briggs"</span>;<br><span class="hljs-keyword">auto</span> arr1 = name; <span class="hljs-comment">// auto被推断为const char*,arr1的类型为const char*</span><br><span class="hljs-keyword">auto</span>&amp; arr2 = name; <span class="hljs-comment">// auto被推断为const char[13],arr2 的类型为const char (&amp;)[13]</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)</span></span>; <br><span class="hljs-keyword">auto</span> func1 = someFunc; <span class="hljs-comment">// func1的 类型为 void (*)(int, double)</span><br><span class="hljs-keyword">auto</span>&amp; func2 = someFunc; <span class="hljs-comment">// func2的类型为 void (&amp;)(int, double)</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>大多数场景下auto推断规则和模板参数推断规则相通，有一种特殊情况，就是统一初始化式。可以看下下述3个例子的区别</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">auto</span> x = { <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> }; <span class="hljs-comment">// x的类型为 std::initializer_list&lt;int&gt;</span><br><br><span class="hljs-comment">// error</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 和auto x等同的模板类型推断</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T param)</span></span>; <br><br><span class="hljs-built_in">f</span>({ <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> }); <span class="hljs-comment">// 错误！这里不能推断T的类型。</span><br><br><span class="hljs-comment">// ok</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(std::initializer_list&lt;T&gt; initList)</span></span>;<br><br><span class="hljs-built_in">f</span>({ <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">9</span> });                   <span class="hljs-comment">// T被推导成int，initList的</span><br>                                    <span class="hljs-comment">// 类型是std::initializer_list&lt;int&gt;</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[^1]https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch01.html<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++四种强制类型转换</title>
    <link href="/2021/11/08/c-si-chong-qiang-zhi-lei-xing-zhuan-huan/"/>
    <url>/2021/11/08/c-si-chong-qiang-zhi-lei-xing-zhuan-huan/</url>
    
    <content type="html"><![CDATA[<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>有时我们希望显式地将对象转换为另外一种类型。例如，如果想在下面的代码中执行浮点数除法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i,j;<br><span class="hljs-keyword">double</span> slope = i/j;<br></code></pre></td></tr></tbody></table></figure><p>就要使用某种方法将<code>i/j</code>的结果显示地转换为double。这种方法称作强制类型转换。</p><h3 id="C风格的强制类型转换"><a href="#C风格的强制类型转换" class="headerlink" title="C风格的强制类型转换"></a>C风格的强制类型转换</h3><p>C风格地进行强制类型转换包含两种形式:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">type(expr);<br>(type)type;<br></code></pre></td></tr></tbody></table></figure><p>C风格的强制类型转换从表现形式上来说不那么清楚明了，一旦出现问题，追踪起来比较困难。</p><h3 id="C-风格的强制类型转换"><a href="#C-风格的强制类型转换" class="headerlink" title="C++风格的强制类型转换"></a>C++风格的强制类型转换</h3><p>C++风格的强制类型转换具有如下形式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cast-name&lt;type&gt;(expression);<br></code></pre></td></tr></tbody></table></figure><p><code>cast-name</code>可以是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种。</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><p><code>static_cast</code>会在编译期间对类型转换做安全检查，防止不必要的错误。几个主要的用法如下：</p><ol><li><p>基础类型间的转换，如<code>int</code>转为<code>char</code>,float转为double。因为<code>static_cast</code>明确告诉编译器是在知情情况下发生的类型转换，所以对可能的精度损失不会告警。把精度大的值转换为精度小的值，<code>static_cast</code>会做截断处理。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> n1 = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-keyword">int32_t</span> n2 = n1;                                   <span class="hljs-comment">//  warning: conversion from 'int64_t' {aka 'long long int'} to 'int32_t' {aka 'int'} may change value</span><br><span class="hljs-keyword">int32_t</span> n3 = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;(n1);             <span class="hljs-comment">//  no warning</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>把任意类型转换为void类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> num=<span class="hljs-number">64</span>;<br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>&gt;(num);<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>void*</code>指针和目标类型指针的相互转换</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> strArr[<span class="hljs-number">11</span>] = <span class="hljs-string">"helloworld"</span>;<br><span class="hljs-keyword">void</span> *pVoid = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(strArr);<br><span class="hljs-keyword">char</span>* ptrStr=<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pVoid);<br></code></pre></td></tr></tbody></table></figure></li><li><p>用于基类和子类间的转换，但没有运行时类型检查保证转换安全，其中，子类转基类是安全的，但是父类转子类是不安全的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {</span>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> :</span> <span class="hljs-keyword">public</span> B {};<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B* pb, D* pd)</span> </span>{<br>  D* pd2 = <span class="hljs-keyword">static_cast</span>&lt;D*&gt;(pb);   <span class="hljs-comment">// Not safe, D can have fields</span><br>                                   <span class="hljs-comment">// and methods that are not in B.</span><br><br>  B* pb2 = <span class="hljs-keyword">static_cast</span>&lt;B*&gt;(pd);   <span class="hljs-comment">// Safe conversion, D always</span><br>                                   <span class="hljs-comment">// contains all of B.</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>static_cast</code>不能进行无关类型（如非父类和子类）指针之间的转换</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int64_t</span> n1 = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-comment">// error: invalid static_cast from type 'int64_t*' {aka 'long long int*'} to type 'char*'</span><br><span class="hljs-keyword">char</span>* ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(&amp;n1); <br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast转换符是用来移除变量的const或volatile限定符。对于const变量，我们无法直接改变它的值，这个时候<code>const_cast</code>可以派上用场</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAddr</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span>* ptr)</span></span><br><span class="hljs-function"></span>{<br>    std::cout&lt;&lt;std::hex&lt;&lt;ptr&lt;&lt;std::oct&lt;&lt;std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span>* ptrNum=&amp;num;<br>    <span class="hljs-comment">//printAddr(ptrNum);     invalid conversion from 'const int32_t*' {aka 'const int*'} to 'int32_t*'</span><br>    <span class="hljs-built_in">printAddr</span>(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int32_t</span>*&gt;(ptrNum));<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p><code>reinterpret</code>字面意识是重新解释，<code>reinterpret_cast</code>可以理解为重新解释数值，它可以实现</p><ol><li><p>任意类型指针转换为其他无关类型的指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span></span><br><span class="hljs-class">{</span><br>    <span class="hljs-keyword">int32_t</span> num;<br>    <span class="hljs-keyword">char</span> ch;<br>};<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Data data{<span class="hljs-number">0x12345678</span>,<span class="hljs-string">'A'</span>};<br>    <span class="hljs-keyword">int32_t</span>* ptr=<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int32_t</span>*&gt;(&amp;data);<br>    std::cout&lt;&lt;std::hex&lt;&lt;*ptr&lt;&lt;std::endl;   <span class="hljs-comment">//  0x12345678</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>整形转换为任意类型指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">uint64_t</span> addr = <span class="hljs-number">0x12345678FFFFFFFF</span>;<br><span class="hljs-keyword">char</span>* ptr=<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(addr);<br>std::cout&lt;&lt;std::hex&lt;&lt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)&lt;&lt;std::endl;    <span class="hljs-comment">// 0x12345678FFFFFFFF</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>任意类型指针转换为足够大的整形</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> ch = <span class="hljs-string">'A'</span>;<br><span class="hljs-comment">//uint32_t lAddr=reinterpret_cast&lt;uint32_t&gt;(&amp;ch);   error: cast from 'char*' to 'uint32_t' {aka 'unsigned int'} loses precision</span><br><span class="hljs-keyword">uint64_t</span> lAddr = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(&amp;ch);<br>std::cout &lt;&lt; std::hex &lt;&lt; <span class="hljs-string">"lAddr : "</span> &lt;&lt; lAddr &lt;&lt; <span class="hljs-string">" , ch addr : "</span> &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(&amp;ch) &lt;&lt; std::endl;<br><span class="hljs-comment">// llNum : 0x65fe17 , ch addr : 0x65fe17</span><br></code></pre></td></tr></tbody></table></figure></li></ol><p><code>reinterpret_cast</code>不考虑转换数值类型之间是否是相关的，所以存在相当大的不安全性,如下例子整形指针转换为函数指针最终导致崩溃</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*pFunc)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">int32_t</span> num=<span class="hljs-number">100</span>;<br>    pFunc pf=<span class="hljs-keyword">reinterpret_cast</span>&lt;pFunc&gt;(&amp;num);<br>    <span class="hljs-built_in">pf</span>(<span class="hljs-number">3</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><p><code>dynamic_cast</code>用于将基类的指针或引用安全地转换成派生类的指针或引用(基类至少要包含一个虚函数)，该转换特别适用于我们想使用基类对象的指针或引用执行某个派生类操作且该操作不是虚函数的情况。如果<code>dynamic_cast</code>转换失败了，如果转换目标是指针类型则返回空指针，如果是引用类型则会抛出一个<code>bad_alloc</code>异常</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CAnimal</span></span><br><span class="hljs-class">{</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        <br>    }<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CAnimal</span>()<br>    {<br><br>    }<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CDog</span>:</span><span class="hljs-keyword">public</span> CAnimal<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>{<br>        <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        std::cout&lt;&lt;<span class="hljs-string">"bark"</span>&lt;&lt;std::endl;<br>    }<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CDog</span>()<br>    {<br>        <br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    CAnimal* animal=<span class="hljs-keyword">new</span> CDog;<br>    CDog* dog=<span class="hljs-keyword">dynamic_cast</span>&lt;CDog*&gt;(animal);<br>    <span class="hljs-keyword">if</span> (dog)<br>    {<br>        dog-&gt;<span class="hljs-built_in">bark</span>();<br>    }<br>    <span class="hljs-keyword">delete</span> animal;<br>}<br></code></pre></td></tr></tbody></table></figure><p>PS:通过运行时类型识别(<code>run-time type identification,RTTI</code>)，程序能够通过基类的指针或引用来检索其所指对象的实际类型。 <code>dynamic_cast</code>是<code>C++</code>中<code>RTTI</code>的一种实现，另一个是<code>typdid</code>。对于带虚函数的类，在运行时执行<code>RTTI</code>操作符，返回动态类型信息；对于其他类型，在编译时执行<code>RTTI</code>，返回静态类型信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>C++</code>支持4种强制类型转换：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code></li><li><code>static_cast</code>会在编译期间对类型转换做安全检查，多用于基础类型的转换，是工作中常用的一种显示转换</li><li><code>dynamic_cast</code>提供了<code>RTTI</code>的功能，支持将带虚函数的基类指针或引用安全地转换为派生类的指针或引用</li><li><code>const_cast</code>用于移除变量的const或volatile限定符</li><li><code>reinterpret_cast</code>支持任意指针类型间的相互转换，功能强大但也比较危险，使用时要谨慎</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[^1]https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2012/5f6c9f8h(v=vs.110)<br>[^2]https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1?topic=operators-cast-expressions<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>觉得不错的书单</title>
    <link href="/2021/11/07/shu-dan/"/>
    <url>/2021/11/07/shu-dan/</url>
    
    <content type="html"><![CDATA[<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><ol><li>C程序设计语言</li><li>C和指针</li><li>C陷阱与缺陷</li><li>C专家编程</li></ol><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><ol><li>C++ primer</li><li>C++标准库</li><li>深度探索 C++ 对象模型</li><li>Effective C++</li><li>Effective Modern C++</li></ol><h3 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix\Linux"></a>Unix\Linux</h3><ol><li>UNIX编程艺术</li><li>UNIX环境高级编程</li><li>UNIX 网络编程卷 1：套接字 API</li><li>UNIX 网络编程卷 2：进程间通信</li><li>深入理解linux内核</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>深入理解计算机系统</li><li>操作系统–精髓与设计原理</li><li>程序员的自我修养：链接、装载与库</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol><li>Head First设计模式</li><li>设计模式: 可复用面向对象软件的基础</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>算法导论</li><li>编程珠玑</li><li>数据结构与算法分析：C语言描述</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>测试驱动开发</li></ol><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li>Docker从入门到实践</li><li>Docker容器与容器云</li></ol>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书单</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
